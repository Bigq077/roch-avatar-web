<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roch Avatar Chat Test</title>

  <!-- ‚úÖ LiveKit client (LOCAL FILE ‚Äì bulletproof) -->
  <script defer src="/livekit-client.umd.min.js"></script>

  <style>
    /* your CSS */
  </style>
</head>

  <style>
    body { font-family: Arial, sans-serif; max-width: 860px; margin: 40px auto; padding: 0 16px; }
    #chat { border: 1px solid #ddd; border-radius: 8px; padding: 12px; min-height: 220px; max-height: 360px; overflow:auto; }
    .msg { margin: 10px 0; }
    .me { font-weight: 700; }
    .ai { font-weight: 700; }
    textarea { width: 100%; height: 70px; padding: 10px; }
    button { padding: 10px 14px; cursor: pointer; }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .row { display: flex; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap; }
    input { padding: 8px; }
    small { color: #666; }
    .hint { margin-top: 8px; }
    .card { border:1px solid #eee; border-radius: 12px; padding:12px; }
    #avatarWrap { display:flex; gap:16px; flex-wrap: wrap; align-items:flex-start; }

    /* ‚úÖ Live video */
    #avatarVideo {
      width: 320px;
      max-width: 100%;
      border-radius: 12px;
      background: #000;
    }

    #status { min-height: 18px; }
    #liveStatus { min-height: 18px; }
  </style>
</head>
<body>
  <h1>Roch Avatar Chat ‚Äî Interactive Avatar (Mode 2)</h1>
  <p><small>Text + Voice ‚Üí AI brain ‚Üí LiveAvatar (LiveKit). Fallback: Deepgram TTS</small></p>

  <div class="row">
    <label>Clinic ID:</label>
    <input id="clinicId" value="demo" />
    <label>Session ID:</label>
    <input id="sessionId" />
  </div>

  <div id="avatarWrap" class="row">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <strong>Avatar</strong>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="connectLiveBtn">üü¢ Connect Live</button>
          <button id="disconnectLiveBtn" disabled>üî¥ Disconnect</button>
        </div>
      </div>

      <div style="margin-top:8px;">
        <small id="liveStatus">Not connected.</small>
      </div>

      <video id="avatarVideo" playsinline autoplay muted></video>

      <div style="margin-top:8px;">
        <label style="display:flex; align-items:center; gap:6px; font-size: 13px;">
          <input type="checkbox" id="muteToggle" checked />
          Muted (recommended)
        </label>
        <small style="display:block; margin-top:6px;">
          Tip: Leave muted for autoplay. If you unmute, browsers may require a click each time.
        </small>
      </div>
    </div>

    <div style="flex:1; min-width: 320px;">
      <div id="chat"></div>

      <div class="row">
        <textarea id="message" placeholder="Type a question (e.g. 'What are your opening hours?')"></textarea>
      </div>

      <div class="row">
        <button id="sendBtn">Send</button>
        <button id="recBtn">üéô Record</button>
        <button id="stopRecBtn" disabled>‚èπ Stop</button>
        <span id="status"></span>
      </div>

      <p class="hint">
        <small>
          Live connect ‚Üí <code>/avatar/live/start</code> ‚Üí LiveKit WebRTC<br/>
          Text ‚Üí <code>/avatar/chat</code> (brain) ‚Üí avatar speaks immediately<br/>
          Voice ‚Üí <code>/avatar/voice-turn</code> (STT+brain) ‚Üí avatar speaks immediately<br/>
          Fallback voice out ‚Üí <code>/avatar/tts</code>
        </small>
      </p>
    </div>
  </div>

  <script>
    // ---------------------------
    // CONFIG
    // ---------------------------
    const BACKEND_BASE_URL = "https://rochsolutions-ai-receptionist.onrender.com";

    // LiveKit UMD global can differ depending on build
    function getLiveKitGlobal() {
      return window.LiveKit || window.livekit || window.LivekitClient || null;
    }

    // ---------------------------
    // SESSION
    // ---------------------------
    const sessionIdInput = document.getElementById("sessionId");
    const clinicIdInput = document.getElementById("clinicId");
    const existing = localStorage.getItem("roch_session_id");
    const newId = existing || (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
    localStorage.setItem("roch_session_id", newId);
    sessionIdInput.value = newId;

    const chat = document.getElementById("chat");
    const statusEl = document.getElementById("status");
    const liveStatusEl = document.getElementById("liveStatus");

    const sendBtn = document.getElementById("sendBtn");
    const messageEl = document.getElementById("message");

    const recBtn = document.getElementById("recBtn");
    const stopRecBtn = document.getElementById("stopRecBtn");

    const videoEl = document.getElementById("avatarVideo");
    const muteToggle = document.getElementById("muteToggle");
    muteToggle.addEventListener("change", () => {
      videoEl.muted = muteToggle.checked;
    });

    function setStatus(text) { statusEl.textContent = text || ""; }
    function setLiveStatus(text) { liveStatusEl.textContent = text || ""; }

    function setBusy(isBusy) {
      sendBtn.disabled = isBusy;
      recBtn.disabled = isBusy;
      messageEl.disabled = isBusy;
      clinicIdInput.disabled = isBusy;
      sessionIdInput.disabled = isBusy;
    }

    function addMsg(who, text) {
      const div = document.createElement("div");
      div.className = "msg";
      div.innerHTML = `<span class="${who === "You" ? "me" : "ai"}">${who}:</span> ${escapeHtml(text)}`;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    // ---------------------------
    // LIVEKIT / LIVEAVATAR (Mode 2)
    // ---------------------------
    let room = null;
    let liveSession = null; // {liveavatar_session_id, livekit_url, livekit_token}

    const connectBtn = document.getElementById("connectLiveBtn");
    const disconnectBtn = document.getElementById("disconnectLiveBtn");

    function roomOn(evt, fn) {
      // Compatibility: constants OR string events
      try { room.on(evt, fn); } catch {}
    }

    async function connectLiveAvatar() {
      const LK = getLiveKitGlobal();
      if (!LK || !LK.Room) {
        throw new Error("LiveKit client not found. Check the UMD <script> tag is loaded before this script.");
      }

      const clinic_id = clinicIdInput.value.trim();
      const session_id = sessionIdInput.value.trim();

      setLiveStatus("Starting LiveAvatar session‚Ä¶");

      const res = await fetch(`${BACKEND_BASE_URL}/avatar/live/start`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clinic_id, session_id })
      });

      if (!res.ok) throw new Error(await res.text());
      liveSession = await res.json();

      setLiveStatus("Connecting to LiveKit‚Ä¶");

      room = new LK.Room({
        adaptiveStream: true,
        dynacast: true
      });

      // Track subscribed (video)
      const TRACK_EVT = (LK.RoomEvent && LK.RoomEvent.TrackSubscribed) || "trackSubscribed";
      roomOn(TRACK_EVT, (track, publication, participant) => {
        if (track && track.kind === "video") {
          track.attach(videoEl);
          // Ensure autoplay best practice
          videoEl.muted = muteToggle.checked;
          videoEl.play().catch(() => {});
          setLiveStatus("Live Avatar connected ‚úÖ");
        }
      });

      // Disconnected
      const DISC_EVT = (LK.RoomEvent && LK.RoomEvent.Disconnected) || "disconnected";
      roomOn(DISC_EVT, () => {
        setLiveStatus("Disconnected.");
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
      });

      // Optional: agent-response listener (useful for debugging)
      const DATA_EVT = (LK.RoomEvent && LK.RoomEvent.DataReceived) || "dataReceived";
      roomOn(DATA_EVT, (payload, participant, kind, topic) => {
        if (topic !== "agent-response") return;
        try {
          const msg = JSON.parse(new TextDecoder().decode(payload));
          // console.log("agent-response:", msg);
        } catch {}
      });

     console.log("RAW livekit_url:", liveSession.livekit_url);
     const lkUrl = liveSession.livekit_url.replace(/^wss:\/\//, "https://");
     console.log("CONNECTING TO:", lkUrl);
     await room.connect(lkUrl, liveSession.livekit_token);


      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      setLiveStatus("Connected. Waiting for video‚Ä¶");
    }

    async function disconnectLiveAvatar() {
      try {
        if (room) {
          room.disconnect();
          room = null;
        }
      } finally {
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        setLiveStatus("Disconnected.");
      }
    }

  // ‚úÖ LiveKit v1-compatible speak command (HeyGen LiveAvatar)
async function speakOnAvatar(text) {
  if (!room || !text || !liveSession?.liveavatar_session_id) return false;

  const msg = {
    event_type: "avatar.speak_text",
    session_id: liveSession.liveavatar_session_id,
    text: text,
    channel: "agent-control" // since v1 may not support topics
  };

  try {
    const bytes = new TextEncoder().encode(JSON.stringify(msg));

    // ‚úÖ LiveKit v1 signature: (payload, reliable:boolean)
    await room.localParticipant.publishData(bytes, true);

    return true;
  } catch (e) {
    console.warn("publishData failed:", e);
    return false;
  }
}


    connectBtn.onclick = () => {
      connectLiveAvatar().catch(err => {
        console.error(err);
        setLiveStatus("Connect failed (check console).");
      });
    };

    disconnectBtn.onclick = () => {
      disconnectLiveAvatar().catch(err => console.error(err));
    };

    // ---------------------------
    // DEEPGRAM TTS (fallback)
    // ---------------------------
    async function speakViaBackend(text) {
      if (!text) return;
      try {
        const res = await fetch(`${BACKEND_BASE_URL}/avatar/tts`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });

        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();

        const audio = new Audio(`data:${data.mime_type};base64,${data.audio_b64}`);
        await audio.play();
      } catch (err) {
        console.error("TTS error:", err);
      }
    }

    // ---------------------------
    // TEXT CHAT -> speak (Mode 2)
    // ---------------------------
    async function send() {
      const clinic_id = clinicIdInput.value.trim();
      const session_id = sessionIdInput.value.trim();
      const message = messageEl.value.trim();
      if (!message) return;

      addMsg("You", message);
      messageEl.value = "";

      setBusy(true);
      setStatus("Thinking‚Ä¶");

      try {
        const res = await fetch(`${BACKEND_BASE_URL}/avatar/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ clinic_id, session_id, message })
        });

        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        const replyText = data.reply_text || "(no reply)";

        addMsg("AI", replyText);

        setStatus("Speaking‚Ä¶");
        const ok = await speakOnAvatar(replyText);

        if (!ok) {
          setStatus("Avatar not connected ‚Äî audio fallback‚Ä¶");
          await speakViaBackend(replyText);
        }

        setStatus("OK");
      } catch (err) {
        console.error(err);
        setStatus("Error");
      } finally {
        setBusy(false);
      }
    }

    sendBtn.onclick = send;
    messageEl.onkeydown = e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    };

    // ---------------------------
    // VOICE INPUT (STT + brain) -> speak (Mode 2)
    // ---------------------------
    let mediaRecorder, audioChunks = [], stream;

    recBtn.onclick = async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert("Microphone permission denied.");
        return;
      }

      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });

      mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

      mediaRecorder.onstop = async () => {
        stream.getTracks().forEach(t => t.stop());
        const blob = new Blob(audioChunks, { type: "audio/webm" });
        await handleVoiceBlob(blob);
      };

      mediaRecorder.start();
      recBtn.disabled = true;
      stopRecBtn.disabled = false;
      setStatus("Recording‚Ä¶");
    };

    stopRecBtn.onclick = () => {
      mediaRecorder.stop();
      stopRecBtn.disabled = true;
      setStatus("Uploading‚Ä¶");
    };

    async function handleVoiceBlob(blob) {
      setBusy(true);

      try {
        const fd = new FormData();
        fd.append("clinic_id", clinicIdInput.value.trim());
        fd.append("session_id", sessionIdInput.value.trim());
        fd.append("audio", blob, "speech.webm");

        const sttRes = await fetch(`${BACKEND_BASE_URL}/avatar/voice-turn`, {
          method: "POST",
          body: fd
        });

        if (!sttRes.ok) throw new Error(await sttRes.text());
        const sttData = await sttRes.json();

        const transcript = (sttData.transcript || "").trim();
        const replyText = (sttData.reply_text || "").trim();

        if (!transcript) {
          setStatus("Could not transcribe ‚Äî try again.");
          return;
        }

        addMsg("You", transcript);

        if (replyText) {
          addMsg("AI", replyText);
          setStatus("Speaking‚Ä¶");

          const ok = await speakOnAvatar(replyText);
          if (!ok) {
            setStatus("Avatar not connected ‚Äî audio fallback‚Ä¶");
            await speakViaBackend(replyText);
          }
          setStatus("OK");
        } else {
          setStatus("No reply.");
        }
      } catch (err) {
        console.error(err);
        setStatus("Error");
      } finally {
        setBusy(false);
        recBtn.disabled = false;
        stopRecBtn.disabled = true;
      }
    }

    // ---------------------------
    // Clean disconnect when leaving page (best effort)
    // ---------------------------
    window.addEventListener("beforeunload", () => {
      try { if (room) room.disconnect(); } catch {}
    });
  </script>
</body>
</html>
